const { INITIAL_BALANCE } = require('../config');
const ChainUtil = require("../chain-util")
const Transaction = require('./transaction');


class Wallet{
    /**
     * the wallet will hold the public key
     * and the private key pair
     * and the balance
     */
    constructor(){
        this.balance = INITIAL_BALANCE;
        this.keyPair = ChainUtil.genKeyPair();
        this.publicKey = this.keyPair.getPublic().encode('hex');

    }


        sign(dataHash){
        return this.keyPair.sign(dataHash);
        }


        createTransaction(toAddress, amount, blockchain, transactionPool){


        this.balance = this.calculateBalance(blockchain, transactionPool);

            if(amount > this.balance){
                console.log(`Amount: ${amount} exceeds the current balance: ${this.balance}`);
                return;
            }
            
            // let transaction = transactionPool.existingTransaction(this.publicKey);
    
            // if(transaction){
            //     // creates more outputs
            //     transaction.update(this,recipient,amount)
            // }
            // else{
                // creates a new transaction and updates the transaction pool
               let transaction = Transaction.newTransaction(this, toAddress, amount);
                transactionPool.updateOrAddTransaction(transaction);
            // }
    
            return transaction;
    
        }



    static blockchainWallet(){
            const blockchainWallet = new this();
            blockchainWallet.publicKey = 'blockchain-wallet';
            blockchainWallet.balance = 10000000000000
            return blockchainWallet;
            }


            /**
     * updates the balance of the wallet
     * based on the latest transaction
     */


    updateBalance(blockchain, transactionPool){

           // store the existing balance
           let balance = this.balance;

           // create an array of transactions
           let transactions = [];
   
           // store all the transactions in the array
           blockchain.chain.forEach(block => block.transactions.forEach(transaction =>{
               transactions.push(transaction);
           }));
           transactionPool.transactions.forEach(tx => transactions.push(tx));

           if (transactions.length > 0){

            // get all the transactions generated by the wallet ie money sent by the wallet
            const walletOutTransactions = transactions.filter(transaction => transaction.fromAddress === this.publicKey);
            let coinsSpend = this.getCoinsSendOrRecived(walletOutTransactions)
    
            const walletInTransactions = transactions.filter(transaction => transaction.toAddress === this.publicKey);
            let coinsRecived = this.getCoinsSendOrRecived(walletInTransactions)
            
            // CHANGE THE 500 to 0 later !!!!!
            let sum = 500 + coinsRecived - coinsSpend
            balance = sum
            }
            this.balance = balance

            return this.balance

    }

    calculateBalance(blockchain, transactionPool){
        
        // store the existing balance
        let balance = this.balance;

        // create an array of transactions
        let transactions = [];

        // store all the transactions in the array
        blockchain.chain.forEach(block => block.transactions.forEach(transaction =>{
            transactions.push(transaction);
        }));

        transactionPool.transactions.forEach(tx => transactions.push(tx));

       

        if (transactions.length > 0){

        // get all the transactions generated by the wallet ie money sent by the wallet
        const walletOutTransactions = transactions.filter(transaction => transaction.fromAddress === this.publicKey);
        let coinsSpend = this.getCoinsSendOrRecived(walletOutTransactions)

        const walletInTransactions = transactions.filter(transaction => transaction.toAddress === this.publicKey);
        let coinsRecived = this.getCoinsSendOrRecived(walletInTransactions)
        
        // CHANGE THE 500 to 0 later !!!!!
            console.log("CoinsR" + coinsRecived)
            console.log("CoinsSpend" + coinsSpend)
        let sum = 500 + coinsRecived - coinsSpend
        balance = sum
        }
        // // declare a variable to save the timestamp
        // let startTime = 0;

        // if(walletInputTransactions.length > 0){

        //     // get the latest transaction
        //     const recentInputTransaction = walletInputTransactions.reduce((prev,current)=> prev.timestamp > current.timestamp ? prev : current );
            
        //     // get the outputs of that transactions, its amount will be the money that we would get back
        //     balance = recentInputTransaction.senderBalance

        //     // save the timestamp of the latest transaction made by the wallet
        //     startTime = recentInputTransaction.timestamp
        // }

        // get the transactions that were addressed to this wallet ie somebody sent some moeny
        // and add its ouputs.
        // since we save the timestamp we would only add the outputs of the transactions recieved
        // only after the latest transactions made by us

        // transactions.forEach(transaction =>{
        //     if(transaction.input.timestamp > startTime){
                
        //             if(transaction.toWallet === this.publicKey){
        //                 balance += transaction.amount;
        //             }
                
        //     }
        // })

        return balance;

    }


    getCoinsSendOrRecived(transactions){
        console.log("getting")
        if (transactions.length > 1){
          
       return transactions.reduce((total, tx) =>{
        
           return total += tx.amount
        }, 0)
         } else if (transactions.length == 1){
             return transactions[0].amount
         }
    return 0;
    }

 


     getAllTransactions(blockchain, transactionPool){

         // create an array of transactions
                 let transactions = [];

        // store all the transactions in the array
            blockchain.chain.forEach(block => block.transactions.forEach(transaction =>{
               transactions.push(transaction);
            }));

            transactionPool.transactions.forEach(tx => transactions.push(tx));

            let all = transactions.filter((transaction) => {
                  if (transaction.fromAddress === this.publicKey ) return true;

                   if (transaction.toAddress === this.publicKey ) return true;
    
                      return false;
                });

            return all;

        }






    toString(){
        return `Wallet - 
        publicKey: ${this.publicKey.toString()}
        balance  : ${this.balance}`
    }



}

module.exports = Wallet